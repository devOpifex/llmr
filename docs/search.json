[{"path":[]},{"path":"https://llmr.opifex.org/CLAUDE.html","id":"development-commands","dir":"","previous_headings":"","what":"Development Commands","title":"CLAUDE.md - Guidelines for llmr R Package","text":"Build package: R CMD build . Check package: R CMD check ---cran llmr_*.tar.gz Install package: R CMD INSTALL . Run tests: Rscript -e 'devtools::test()' Run single test: Rscript -e 'devtools::test_file(\"tests/testthat/test-filename.R\")' Documentation: Rscript -e 'devtools::document()' Lint code: Rscript -e 'lintr::lint_package()' Style code: Rscript -e 'styler::style_pkg()'","code":""},{"path":"https://llmr.opifex.org/CLAUDE.html","id":"code-style-guidelines","dir":"","previous_headings":"","what":"Code Style Guidelines","title":"CLAUDE.md - Guidelines for llmr R Package","text":"Use roxygen2 documentation (markdown = TRUE) Function names: use snake_case public functions, dot prefix internal functions Constructor pattern: use new_* prefix constructors Imports: Place top file, one per line, alphabetized Types: Use R’s S3 class system explicit structure() class attributes Error handling: Use stopifnot() assertions, provide informative error messages Format: 2-space indentation, 80-character line width Follow tidyverse style guide conventions Prioritze early returns nesting, avoid else Use {httr2} HTTP requests","code":""},{"path":[]},{"path":"https://llmr.opifex.org/CONTEXT.html","id":"buildtestlint-commands","dir":"","previous_headings":"","what":"Build/Test/Lint Commands","title":"CONTEXT.md - llmr R Package Development Guide","text":"Build/check/install: make (make install, make check, make document) Test : Rscript -e 'devtools::test()' Test single: Rscript -e 'devtools::test_file(\"tests/testthat/test-filename.R\")' Lint: Rscript -e 'lintr::lint_package()' Style: Rscript -e 'styler::style_pkg()' Site: make site","code":""},{"path":"https://llmr.opifex.org/CONTEXT.html","id":"code-style","dir":"","previous_headings":"","what":"Code Style","title":"CONTEXT.md - llmr R Package Development Guide","text":"Functions: snake_case public, .dot_prefix internal, new_* constructors Documentation: roxygen2 markdown = TRUE Imports: Top file, one per line, alphabetized Types: S3 classes explicit structure() class attributes Error handling: stopifnot() assertions, informative error messages Format: 2-space indent, 80-char width, early returns nesting, avoid else HTTP: Use {httr2} requests Follow tidyverse style guide","code":""},{"path":"https://llmr.opifex.org/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 2, June 1991Copyright © 1989, 1991 Free Software Foundation, Inc.,51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://llmr.opifex.org/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"licenses software designed take away freedom share change . contrast, GNU General Public License intended guarantee freedom share change free software–make sure software free users. General Public License applies Free Software Foundation’s software program whose authors commit using . (Free Software Foundation software covered GNU Lesser General Public License instead.) can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge service wish), receive source code can get want , can change software use pieces new free programs; know can things. protect rights, need make restrictions forbid anyone deny rights ask surrender rights. restrictions translate certain responsibilities distribute copies software, modify . example, distribute copies program, whether gratis fee, must give recipients rights . must make sure , , receive can get source code. must show terms know rights. protect rights two steps: (1) copyright software, (2) offer license gives legal permission copy, distribute /modify software. Also, author’s protection , want make certain everyone understands warranty free software. software modified someone else passed , want recipients know original, problems introduced others reflect original authors’ reputations. Finally, free program threatened constantly software patents. wish avoid danger redistributors free program individually obtain patent licenses, effect making program proprietary. prevent , made clear patent must licensed everyone’s free use licensed . precise terms conditions copying, distribution modification follow.","code":""},{"path":"https://llmr.opifex.org/LICENSE.html","id":"terms-and-conditions-for-copying-distribution-and-modification","dir":"","previous_headings":"","what":"TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION","title":"GNU General Public License","text":"0. License applies program work contains notice placed copyright holder saying may distributed terms General Public License. “Program”, , refers program work, “work based Program” means either Program derivative work copyright law: say, work containing Program portion , either verbatim modifications /translated another language. (Hereinafter, translation included without limitation term “modification”.) licensee addressed “”. Activities copying, distribution modification covered License; outside scope. act running Program restricted, output Program covered contents constitute work based Program (independent made running Program). Whether true depends Program . 1. may copy distribute verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice disclaimer warranty; keep intact notices refer License absence warranty; give recipients Program copy License along Program. may charge fee physical act transferring copy, may option offer warranty protection exchange fee. 2. may modify copy copies Program portion , thus forming work based Program, copy distribute modifications work terms Section 1 , provided also meet conditions: ) must cause modified files carry prominent notices stating changed files date change. b) must cause work distribute publish, whole part contains derived Program part thereof, licensed whole charge third parties terms License. c) modified program normally reads commands interactively run, must cause , started running interactive use ordinary way, print display announcement including appropriate copyright notice notice warranty (else, saying provide warranty) users may redistribute program conditions, telling user view copy License. (Exception: Program interactive normally print announcement, work based Program required print announcement.) requirements apply modified work whole. identifiable sections work derived Program, can reasonably considered independent separate works , License, terms, apply sections distribute separate works. distribute sections part whole work based Program, distribution whole must terms License, whose permissions licensees extend entire whole, thus every part regardless wrote . Thus, intent section claim rights contest rights work written entirely ; rather, intent exercise right control distribution derivative collective works based Program. addition, mere aggregation another work based Program Program (work based Program) volume storage distribution medium bring work scope License. 3. may copy distribute Program (work based , Section 2) object code executable form terms Sections 1 2 provided also one following: ) Accompany complete corresponding machine-readable source code, must distributed terms Sections 1 2 medium customarily used software interchange; , b) Accompany written offer, valid least three years, give third party, charge cost physically performing source distribution, complete machine-readable copy corresponding source code, distributed terms Sections 1 2 medium customarily used software interchange; , c) Accompany information received offer distribute corresponding source code. (alternative allowed noncommercial distribution received program object code executable form offer, accord Subsection b .) source code work means preferred form work making modifications . executable work, complete source code means source code modules contains, plus associated interface definition files, plus scripts used control compilation installation executable. However, special exception, source code distributed need include anything normally distributed (either source binary form) major components (compiler, kernel, ) operating system executable runs, unless component accompanies executable. distribution executable object code made offering access copy designated place, offering equivalent access copy source code place counts distribution source code, even though third parties compelled copy source along object code. 4. may copy, modify, sublicense, distribute Program except expressly provided License. attempt otherwise copy, modify, sublicense distribute Program void, automatically terminate rights License. However, parties received copies, rights, License licenses terminated long parties remain full compliance. 5. required accept License, since signed . However, nothing else grants permission modify distribute Program derivative works. actions prohibited law accept License. Therefore, modifying distributing Program (work based Program), indicate acceptance License , terms conditions copying, distributing modifying Program works based . 6. time redistribute Program (work based Program), recipient automatically receives license original licensor copy, distribute modify Program subject terms conditions. may impose restrictions recipients’ exercise rights granted herein. responsible enforcing compliance third parties License. 7. , consequence court judgment allegation patent infringement reason (limited patent issues), conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. distribute satisfy simultaneously obligations License pertinent obligations, consequence may distribute Program . example, patent license permit royalty-free redistribution Program receive copies directly indirectly , way satisfy License refrain entirely distribution Program. portion section held invalid unenforceable particular circumstance, balance section intended apply section whole intended apply circumstances. purpose section induce infringe patents property right claims contest validity claims; section sole purpose protecting integrity free software distribution system, implemented public license practices. Many people made generous contributions wide range software distributed system reliance consistent application system; author/donor decide willing distribute software system licensee impose choice. section intended make thoroughly clear believed consequence rest License. 8. distribution /use Program restricted certain countries either patents copyrighted interfaces, original copyright holder places Program License may add explicit geographical distribution limitation excluding countries, distribution permitted among countries thus excluded. case, License incorporates limitation written body License. 9. Free Software Foundation may publish revised /new versions General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies version number License applies “later version”, option following terms conditions either version later version published Free Software Foundation. Program specify version number License, may choose version ever published Free Software Foundation. 10. wish incorporate parts Program free programs whose distribution conditions different, write author ask permission. software copyrighted Free Software Foundation, write Free Software Foundation; sometimes make exceptions . decision guided two goals preserving free status derivatives free software promoting sharing reuse software generally.","code":""},{"path":"https://llmr.opifex.org/LICENSE.html","id":"no-warranty","dir":"","previous_headings":"","what":"NO WARRANTY","title":"GNU General Public License","text":"11. PROGRAM LICENSED FREE CHARGE, WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION. 12. EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MAY MODIFY /REDISTRIBUTE PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES. END TERMS CONDITIONS","code":""},{"path":"https://llmr.opifex.org/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively convey exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program interactive, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, commands use may called something show w show c; even mouse-clicks menu items–whatever suits program. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. sample; alter names: General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA. Gnomovision version 69, Copyright (C) year name of author Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'. This is free software, and you are welcome to redistribute it under certain conditions; type `show c' for details. Yoyodyne, Inc., hereby disclaims all copyright interest in the program `Gnomovision' (which makes passes at compilers) written by James Hacker.  <signature of Ty Coon>, 1 April 1989 Ty Coon, President of Vice"},{"path":"https://llmr.opifex.org/articles/advanced-workflows.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Advanced Workflows: Conditional and Dynamic Patterns","text":"linear workflows powerful, real-world data processing often requires sophisticated patterns. llmr package provides advanced workflow capabilities including conditional branching, parallel processing, dynamic routing. vignette explores advanced patterns, showing build intelligent workflows adapt behavior based data characteristics processing requirements.","code":""},{"path":"https://llmr.opifex.org/articles/advanced-workflows.html","id":"what-youll-learn","dir":"Articles","previous_headings":"Introduction","what":"What You’ll Learn","title":"Advanced Workflows: Conditional and Dynamic Patterns","text":"end guide, ’ll understand : Use () conditional branching Implement preprocessors data preparation Create parallel processing workflows Build dynamic routing based data characteristics Combine multiple advanced patterns Design fault-tolerant workflows","code":""},{"path":"https://llmr.opifex.org/articles/advanced-workflows.html","id":"prerequisites","dir":"Articles","previous_headings":"Introduction","what":"Prerequisites","title":"Advanced Workflows: Conditional and Dynamic Patterns","text":"","code":"library(llmr) #>  #> Attaching package: 'llmr' #> The following object is masked from 'package:stats': #>  #>     step"},{"path":"https://llmr.opifex.org/articles/advanced-workflows.html","id":"understanding-when-conditional-branching","dir":"Articles","previous_headings":"Introduction","what":"Understanding when(): Conditional Branching","title":"Advanced Workflows: Conditional and Dynamic Patterns","text":"() function enables conditional branching workflows. takes condition function multiple named branches, executing appropriate branch based condition’s result.","code":""},{"path":"https://llmr.opifex.org/articles/advanced-workflows.html","id":"basic-conditional-workflow","dir":"Articles","previous_headings":"Introduction > Understanding when(): Conditional Branching","what":"Basic Conditional Workflow","title":"Advanced Workflows: Conditional and Dynamic Patterns","text":"","code":"# Define condition function classify_number <- function(x) {   if (x > 100) {     \"large\"   } else if (x > 10) {     \"medium\"   } else {     \"small\"   } }  # Define branch-specific processing process_large <- function(x) {   cat(\"Processing large number:\", x, \"\\n\")   x / 10  # Scale down large numbers }  process_medium <- function(x) {   cat(\"Processing medium number:\", x, \"\\n\")   x * 2   # Double medium numbers }  process_small <- function(x) {   cat(\"Processing small number:\", x, \"\\n\")   x + 100 # Boost small numbers }  # Create conditional workflow number_processor <- when(   classify_number,   large = step(process_large, name = \"scale_down\"),   medium = step(process_medium, name = \"double\"),   small = step(process_small, name = \"boost\") )  # View the workflow structure print(number_processor) #> Workflow conditional branch with 3 branches: #> Branches: large, medium, small  # Test with different values test_values <- c(5, 50, 500) for (val in test_values) {   cat(\"\\n--- Processing:\", val, \"---\\n\")   result <- execute(number_processor, val)   print(result) } #>  #> --- Processing: 5 --- #> Processing small number: 5  #> $small #> [1] 105 #>  #>  #> --- Processing: 50 --- #> Processing medium number: 50  #> $medium #> [1] 100 #>  #>  #> --- Processing: 500 --- #> Processing large number: 500  #> $large #> [1] 50"},{"path":"https://llmr.opifex.org/articles/advanced-workflows.html","id":"preprocessing-with-conditional-branching","dir":"Articles","previous_headings":"Introduction > Understanding when(): Conditional Branching","what":"Preprocessing with Conditional Branching","title":"Advanced Workflows: Conditional and Dynamic Patterns","text":"Combine preprocessing steps conditional logic:","code":"# Preprocessor function validate_and_prepare <- function(x) {   cat(\"Validating input:\", x, \"\\n\")   if (!is.numeric(x)) {     stop(\"Input must be numeric\")   }   abs(x)  # Ensure positive values }  # Create workflow with preprocessing robust_processor <- step(validate_and_prepare, name = \"validate\") %->%   when(     classify_number,     large = step(process_large, name = \"scale_down\"),     medium = step(process_medium, name = \"double\"),     small = step(process_small, name = \"boost\")   )  print(robust_processor) #> Workflow: <unnamed>  #> Nodes: 5 | Edges: 4  #>  #> ┌─ ⚙️ validate #> │ #> ├─ 🔀 when(large, medium, small) #> │   ├─ large: ⚙️ scale_down #> │   ├─ medium: ⚙️ double #> │   └─ small: ⚙️ boost  # Test with various inputs test_inputs <- c(-25, 15, 150) for (input in test_inputs) {   cat(\"\\n--- Processing:\", input, \"---\\n\")   result <- execute(robust_processor, input)   print(result) } #>  #> --- Processing: -25 --- #> > 2025-06-17 12:38:50 [WORKFLOW] Executing node: validate  #> Validating input: -25  #> > 2025-06-17 12:38:50 [WORKFLOW] Executing node: condition_1  #> > 2025-06-17 12:38:50 [WORKFLOW] Condition node 'condition_1' selected branches: medium  #> > 2025-06-17 12:38:50 [WORKFLOW] Executing branch 'medium' -> node 'double_1'  #> > 2025-06-17 12:38:50 [WORKFLOW] Executing node: double  #> Processing medium number: 25  #> $medium #> [1] 50 #>  #>  #> --- Processing: 15 --- #> > 2025-06-17 12:38:50 [WORKFLOW] Executing node: validate  #> Validating input: 15  #> > 2025-06-17 12:38:50 [WORKFLOW] Executing node: condition_1  #> > 2025-06-17 12:38:50 [WORKFLOW] Condition node 'condition_1' selected branches: medium  #> > 2025-06-17 12:38:50 [WORKFLOW] Executing branch 'medium' -> node 'double_1'  #> > 2025-06-17 12:38:50 [WORKFLOW] Executing node: double  #> Processing medium number: 15  #> $medium #> [1] 30 #>  #>  #> --- Processing: 150 --- #> > 2025-06-17 12:38:50 [WORKFLOW] Executing node: validate  #> Validating input: 150  #> > 2025-06-17 12:38:50 [WORKFLOW] Executing node: condition_1  #> > 2025-06-17 12:38:50 [WORKFLOW] Condition node 'condition_1' selected branches: large  #> > 2025-06-17 12:38:50 [WORKFLOW] Executing branch 'large' -> node 'scale_down_1'  #> > 2025-06-17 12:38:50 [WORKFLOW] Executing node: scale_down  #> Processing large number: 150  #> $large #> [1] 15"},{"path":"https://llmr.opifex.org/articles/advanced-workflows.html","id":"parallel-processing-with-when","dir":"Articles","previous_headings":"Introduction","what":"Parallel Processing with when()","title":"Advanced Workflows: Conditional and Dynamic Patterns","text":"Use () execute multiple branches parallel returning multiple branch names:","code":"# Define analysis functions sentiment_analysis <- function(text) {   cat(\"Analyzing sentiment...\\n\")   # Simulate sentiment analysis   sentiments <- c(\"positive\", \"negative\", \"neutral\")   sample(sentiments, 1) }  word_count <- function(text) {   cat(\"Counting words...\\n\")   length(strsplit(text, \"\\\\s+\")[[1]]) }  extract_keywords <- function(text) {   cat(\"Extracting keywords...\\n\")   words <- strsplit(tolower(text), \"\\\\s+\")[[1]]   # Return top 3 unique words   unique_words <- unique(words)   sample(unique_words, min(3, length(unique_words))) }  readability_score <- function(text) {   cat(\"Calculating readability...\\n\")   # Simple readability metric   words <- strsplit(text, \"\\\\s+\")[[1]]   avg_word_length <- mean(nchar(words))   round(avg_word_length, 2) }  # Function to combine parallel results combine_analysis <- function(results) {   cat(\"Combining analysis results...\\n\")   list(     sentiment = results$sentiment,     word_count = results$word_count,     keywords = results$keywords,     readability = results$readability,     summary = paste(       \"Text analysis:\", results$word_count, \"words,\",       results$sentiment, \"sentiment,\",       \"readability score:\", results$readability     )   ) }  # Create parallel analysis workflow text_analyzer <- when(   function(text) c(\"sentiment\", \"word_count\", \"keywords\", \"readability\"),   sentiment = step(sentiment_analysis, name = \"sentiment\"),   word_count = step(word_count, name = \"count_words\"),   keywords = step(extract_keywords, name = \"extract_keys\"),   readability = step(readability_score, name = \"readability\") ) %->%   step(combine_analysis, name = \"combine\")  print(text_analyzer) #> Workflow: <unnamed>  #> Nodes: 6 | Edges: 5  #>  #> ┌─ 🔀 when(sentiment, word_count, keywords, readability) #> │   ├─ sentiment: ⚙️ sentiment #> │   ├─ word_count: ⚙️ count_words #> │   ├─ keywords: ⚙️ extract_keys #> │   └─ readability: ⚙️ readability #> │ #> └─ ⚙️ combine  # Test parallel processing sample_text <- \"The advanced workflow capabilities in llmr enable sophisticated data processing patterns.\" result <- execute(text_analyzer, sample_text) #> > 2025-06-17 12:38:50 [WORKFLOW] Executing node: condition_1  #> > 2025-06-17 12:38:50 [WORKFLOW] Condition node 'condition_1' selected branches: sentiment, word_count, keywords, readability  #> > 2025-06-17 12:38:50 [WORKFLOW] Executing branch 'sentiment' -> node 'sentiment_1'  #> > 2025-06-17 12:38:50 [WORKFLOW] Executing node: sentiment  #> Analyzing sentiment... #> > 2025-06-17 12:38:50 [WORKFLOW] Executing branch 'word_count' -> node 'count_words_1'  #> > 2025-06-17 12:38:50 [WORKFLOW] Executing node: count_words  #> Counting words... #> > 2025-06-17 12:38:50 [WORKFLOW] Executing branch 'keywords' -> node 'extract_keys_1'  #> > 2025-06-17 12:38:50 [WORKFLOW] Executing node: extract_keys  #> Extracting keywords... #> > 2025-06-17 12:38:50 [WORKFLOW] Executing branch 'readability' -> node 'readability_1'  #> > 2025-06-17 12:38:50 [WORKFLOW] Executing node: readability  #> Calculating readability... #> > 2025-06-17 12:38:50 [WORKFLOW] Executing node: combine  #> Combining analysis results... print(result) #> $sentiment #> [1] \"positive\" #>  #> $word_count #> [1] 11 #>  #> $keywords #> [1] \"enable\" \"in\"     \"llmr\"   #>  #> $readability #> [1] 7.18 #>  #> $summary #> [1] \"Text analysis: 11 words, positive sentiment, readability score: 7.18\""},{"path":"https://llmr.opifex.org/articles/advanced-workflows.html","id":"dynamic-routing-based-on-data-characteristics","dir":"Articles","previous_headings":"Introduction","what":"Dynamic Routing Based on Data Characteristics","title":"Advanced Workflows: Conditional and Dynamic Patterns","text":"Create workflows route data based characteristics:","code":"# Data type classifier classify_data_type <- function(data) {   if (is.character(data)) {     if (nchar(data) > 100) {       \"long_text\"     } else {       \"short_text\"     }   } else if (is.numeric(data)) {     if (length(data) > 1) {       \"numeric_vector\"     } else {       \"single_number\"     }   } else {     \"other\"   } }  # Specialized processors for different data types process_long_text <- function(text) {   cat(\"Processing long text (\", nchar(text), \"characters)\\n\")   # Summarize long text   words <- strsplit(text, \"\\\\s+\")[[1]]   paste(\"Summary:\", length(words), \"words starting with:\",      paste(head(words, 3), collapse = \" \")   ) }  process_short_text <- function(text) {   cat(\"Processing short text:\", text, \"\\n\")   # Simple transformation for short text   toupper(text) }  process_numeric_vector <- function(vec) {   cat(\"Processing numeric vector of length\", length(vec), \"\\n\")   list(     mean = mean(vec),     sd = sd(vec),     range = range(vec)   ) }  process_single_number <- function(num) {   cat(\"Processing single number:\", num, \"\\n\")   list(     value = num,     squared = num^2,     sqrt = sqrt(abs(num))   ) }  process_other <- function(data) {   cat(\"Processing other data type:\", class(data), \"\\n\")   paste(\"Unsupported data type:\", class(data)[1]) }  # Create dynamic routing workflow data_router <- when(   classify_data_type,   long_text = step(process_long_text, name = \"long_text_processor\"),   short_text = step(process_short_text, name = \"short_text_processor\"),   numeric_vector = step(process_numeric_vector, name = \"vector_processor\"),   single_number = step(process_single_number, name = \"number_processor\"),   other = step(process_other, name = \"fallback_processor\") )  print(data_router) #> Workflow conditional branch with 5 branches: #> Branches: long_text, short_text, numeric_vector, single_number, other  # Test with different data types test_data <- list(   \"Hello World\",   \"This is a much longer text that contains many words and should be classified as long text for processing purposes.\",   42,   c(1, 2, 3, 4, 5),   factor(c(\"A\", \"B\", \"C\")) )  for (i in seq_along(test_data)) {   cat(\"\\n--- Test\", i, \"---\\n\")   result <- execute(data_router, test_data[[i]])   print(result) } #>  #> --- Test 1 --- #> Processing short text: Hello World  #> $short_text #> [1] \"HELLO WORLD\" #>  #>  #> --- Test 2 --- #> Processing long text ( 114 characters) #> $long_text #> [1] \"Summary: 20 words starting with: This is a\" #>  #>  #> --- Test 3 --- #> Processing single number: 42  #> $single_number #> $single_number$value #> [1] 42 #>  #> $single_number$squared #> [1] 1764 #>  #> $single_number$sqrt #> [1] 6.480741 #>  #>  #>  #> --- Test 4 --- #> Processing numeric vector of length 5  #> $numeric_vector #> $numeric_vector$mean #> [1] 3 #>  #> $numeric_vector$sd #> [1] 1.581139 #>  #> $numeric_vector$range #> [1] 1 5 #>  #>  #>  #> --- Test 5 --- #> Processing other data type: factor  #> $other #> [1] \"Unsupported data type: factor\""},{"path":"https://llmr.opifex.org/articles/advanced-workflows.html","id":"agent-based-conditional-workflows","dir":"Articles","previous_headings":"Introduction","what":"Agent-Based Conditional Workflows","title":"Advanced Workflows: Conditional and Dynamic Patterns","text":"Combine AI agents conditional logic intelligent processing:","code":"# Create provider provider <- new_anthropic()  # Create specialized agents technical_writer <- new_agent(\"technical_writer\", provider) creative_writer <- new_agent(\"creative_writer\", provider) data_analyst <- new_agent(\"data_analyst\", provider)  # Configure agents set_system_prompt(   technical_writer,   \"You are a technical writer. Analyze text for technical accuracy and clarity. Provide structured feedback.\" )  set_system_prompt(   creative_writer,   \"You are a creative writing expert. Analyze text for creativity, style, and emotional impact.\" )  set_system_prompt(   data_analyst,   \"You are a data analyst. Extract quantitative insights and patterns from text.\" )  # Content classifier classify_content <- function(text) {   # Simple heuristic classification   technical_keywords <- c(\"algorithm\", \"function\", \"data\", \"analysis\", \"method\", \"system\")   creative_keywords <- c(\"story\", \"character\", \"emotion\", \"beautiful\", \"imagine\", \"dream\")      text_lower <- tolower(text)   technical_score <- sum(sapply(technical_keywords, function(kw) grepl(kw, text_lower)))   creative_score <- sum(sapply(creative_keywords, function(kw) grepl(kw, text_lower)))      if (technical_score > creative_score) {     \"technical\"   } else if (creative_score > technical_score) {     \"creative\"   } else {     \"general\"   } }  # Create intelligent content processor content_processor <- when(   classify_content,   technical = step(technical_writer, name = \"technical_analysis\"),   creative = step(creative_writer, name = \"creative_analysis\"),   general = step(data_analyst, name = \"general_analysis\") )  print(content_processor) #> Workflow conditional branch with 3 branches: #> Branches: technical, creative, general  # Test with different content types technical_text <- \"The algorithm processes data using advanced statistical methods to optimize system performance.\" creative_text <- \"The beautiful story unfolds as the character embarks on an emotional journey through imagination.\" general_text <- \"The quarterly report shows steady growth across all business segments.\"  test_texts <- list(   technical = technical_text,   creative = creative_text,   general = general_text )  for (type in names(test_texts)) {   cat(\"\\n--- Analyzing\", type, \"content ---\\n\")   result <- execute(content_processor, test_texts[[type]])   cat(\"Analysis result:\", substr(result, 1, 100), \"...\\n\") } #>  #> --- Analyzing technical content --- #> Analysis result: list(list(type = \"text\", text = \"I'd be happy to help you understand this algorithm better! However, ... #>  #> --- Analyzing creative content --- #> Analysis result: list(list(type = \"text\", text = \"What a lovely opening! This sentence sets up so many possibilities  ... #>  #> --- Analyzing general content --- #> Analysis result: list(list(type = \"text\", text = \"That's positive news! Steady growth across all segments suggests th ..."},{"path":"https://llmr.opifex.org/articles/advanced-workflows.html","id":"complex-multi-stage-workflows","dir":"Articles","previous_headings":"Introduction","what":"Complex Multi-Stage Workflows","title":"Advanced Workflows: Conditional and Dynamic Patterns","text":"Combine multiple advanced patterns sophisticated processing:","code":"# Multi-stage document processor document_preprocessor <- function(doc) {   cat(\"Preprocessing document...\\n\")   # Clean and prepare document   cleaned <- trimws(doc)   list(     content = cleaned,     length = nchar(cleaned),     word_count = length(strsplit(cleaned, \"\\\\s+\")[[1]])   ) }  # Document classifier based on length and content classify_document <- function(doc_info) {   if (doc_info$word_count > 100) {     \"long_document\"   } else if (doc_info$word_count > 20) {     \"medium_document\"   } else {     \"short_document\"   } }  # Specialized processors for different document lengths process_long_document <- function(doc_info) {   cat(\"Processing long document...\\n\")   # For long documents, do parallel analysis   execute(     when(       function(x) c(\"summary\", \"keywords\", \"sentiment\"),       summary = step(function(x) paste(\"Summary of\", x$word_count, \"words\"), name = \"summarize\"),       keywords = step(function(x) c(\"key1\", \"key2\", \"key3\"), name = \"extract_keywords\"),       sentiment = step(function(x) \"neutral\", name = \"analyze_sentiment\")     ),     doc_info   ) }  process_medium_document <- function(doc_info) {   cat(\"Processing medium document...\\n\")   list(     type = \"medium\",     analysis = paste(\"Medium document with\", doc_info$word_count, \"words\"),     recommendation = \"Consider expanding or condensing\"   ) }  process_short_document <- function(doc_info) {   cat(\"Processing short document...\\n\")   list(     type = \"short\",     analysis = paste(\"Short document with\", doc_info$word_count, \"words\"),     recommendation = \"Consider expanding content\"   ) }  # Final formatter format_results <- function(analysis) {   cat(\"Formatting final results...\\n\")   list(     timestamp = Sys.time(),     analysis = analysis,     status = \"complete\"   ) }  # Create complex multi-stage workflow document_pipeline <- step(document_preprocessor, name = \"preprocess\") %->%   when(     classify_document,     long_document = step(process_long_document, name = \"process_long\"),     medium_document = step(process_medium_document, name = \"process_medium\"),     short_document = step(process_short_document, name = \"process_short\")   ) %->%   step(format_results, name = \"format\")  print(document_pipeline) #> Workflow: <unnamed>  #> Nodes: 6 | Edges: 5  #>  #> ┌─ ⚙️ preprocess #> │ #> ├─ 🔀 when(long_document, medium_document, short_document) #> │   ├─ long_document: ⚙️ process_long #> │   ├─ medium_document: ⚙️ process_medium #> │   └─ short_document: ⚙️ process_short #> │ #> └─ ⚙️ format  # Test with documents of different lengths test_documents <- list(   short = \"Brief note.\",   medium = \"This is a medium-length document that contains several sentences and      provides a reasonable amount of content for analysis purposes.\",   long = paste(     rep(\"This is a very long document with many repeated sentences to        simulate a lengthy piece of content.\",        10     ),      collapse = \" \"   ) )  for (doc_type in names(test_documents)) {   cat(\"\\n--- Processing\", doc_type, \"document ---\\n\")   result <- execute(document_pipeline, test_documents[[doc_type]])   cat(\"Processing complete. Result type:\", class(result), \"\\n\") } #>  #> --- Processing short document --- #> > 2025-06-17 12:39:15 [WORKFLOW] Executing node: preprocess  #> Preprocessing document... #> > 2025-06-17 12:39:15 [WORKFLOW] Executing node: condition_1  #> > 2025-06-17 12:39:15 [WORKFLOW] Condition node 'condition_1' selected branches: short_document  #> > 2025-06-17 12:39:15 [WORKFLOW] Executing branch 'short_document' -> node 'process_short_1'  #> > 2025-06-17 12:39:15 [WORKFLOW] Executing node: process_short  #> Processing short document... #> > 2025-06-17 12:39:15 [WORKFLOW] Executing node: format  #> Formatting final results... #> Processing complete. Result type: list  #>  #> --- Processing medium document --- #> > 2025-06-17 12:39:15 [WORKFLOW] Executing node: preprocess  #> Preprocessing document... #> > 2025-06-17 12:39:15 [WORKFLOW] Executing node: condition_1  #> > 2025-06-17 12:39:15 [WORKFLOW] Condition node 'condition_1' selected branches: short_document  #> > 2025-06-17 12:39:15 [WORKFLOW] Executing branch 'short_document' -> node 'process_short_1'  #> > 2025-06-17 12:39:15 [WORKFLOW] Executing node: process_short  #> Processing short document... #> > 2025-06-17 12:39:15 [WORKFLOW] Executing node: format  #> Formatting final results... #> Processing complete. Result type: list  #>  #> --- Processing long document --- #> > 2025-06-17 12:39:15 [WORKFLOW] Executing node: preprocess  #> Preprocessing document... #> > 2025-06-17 12:39:15 [WORKFLOW] Executing node: condition_1  #> > 2025-06-17 12:39:15 [WORKFLOW] Condition node 'condition_1' selected branches: long_document  #> > 2025-06-17 12:39:15 [WORKFLOW] Executing branch 'long_document' -> node 'process_long_1'  #> > 2025-06-17 12:39:15 [WORKFLOW] Executing node: process_long  #> Processing long document... #> > 2025-06-17 12:39:15 [WORKFLOW] Executing node: format  #> Formatting final results... #> Processing complete. Result type: list"},{"path":"https://llmr.opifex.org/articles/advanced-workflows.html","id":"error-handling-and-fault-tolerance","dir":"Articles","previous_headings":"Introduction","what":"Error Handling and Fault Tolerance","title":"Advanced Workflows: Conditional and Dynamic Patterns","text":"Build robust workflows error handling:","code":"# Safe processor with error handling safe_processor <- function(data) {   tryCatch({     if (is.character(data) && nchar(data) == 0) {       stop(\"Empty string not allowed\")     }     if (is.numeric(data) && data < 0) {       stop(\"Negative numbers not supported\")     }     # Normal processing     paste(\"Processed:\", data)   }, error = function(e) {     cat(\"Error occurred:\", e$message, \"\\n\")     paste(\"Error:\", e$message)   }) }  # Fallback processor fallback_processor <- function(data) {   cat(\"Using fallback processing...\\n\")   paste(\"Fallback result for:\", as.character(data)) }  # Workflow with error handling robust_workflow <- step(safe_processor, name = \"safe_process\") %->%   when(     function(result) {       if (grepl(\"^Error:\", result)) {         \"error\"       } else {         \"success\"       }     },     error = step(fallback_processor, name = \"fallback\"),     success = step(function(x) paste(\"Success:\", x), name = \"finalize\")   )  print(robust_workflow) #> Workflow: <unnamed>  #> Nodes: 4 | Edges: 3  #>  #> ┌─ ⚙️ safe_process #> │ #> ├─ 🔀 when(error, success) #> │   ├─ error: ⚙️ fallback #> │   └─ success: ⚙️ finalize  # Test error handling test_inputs <- list(\"valid input\", \"\", -5, 42) for (input in test_inputs) {   cat(\"\\n--- Testing input:\", as.character(input), \"---\\n\")   result <- execute(robust_workflow, input)   print(result) } #>  #> --- Testing input: valid input --- #> > 2025-06-17 12:39:15 [WORKFLOW] Executing node: safe_process  #> > 2025-06-17 12:39:15 [WORKFLOW] Executing node: condition_1  #> > 2025-06-17 12:39:15 [WORKFLOW] Condition node 'condition_1' selected branches: success  #> > 2025-06-17 12:39:15 [WORKFLOW] Executing branch 'success' -> node 'finalize_1'  #> > 2025-06-17 12:39:15 [WORKFLOW] Executing node: finalize  #> $success #> [1] \"Success: Processed: valid input\" #>  #>  #> --- Testing input:  --- #> > 2025-06-17 12:39:15 [WORKFLOW] Executing node: safe_process  #> Error occurred: Empty string not allowed  #> > 2025-06-17 12:39:15 [WORKFLOW] Executing node: condition_1  #> > 2025-06-17 12:39:15 [WORKFLOW] Condition node 'condition_1' selected branches: error  #> > 2025-06-17 12:39:15 [WORKFLOW] Executing branch 'error' -> node 'fallback_1'  #> > 2025-06-17 12:39:15 [WORKFLOW] Executing node: fallback  #> Using fallback processing... #> $error #> [1] \"Fallback result for: Error: Empty string not allowed\" #>  #>  #> --- Testing input: -5 --- #> > 2025-06-17 12:39:15 [WORKFLOW] Executing node: safe_process  #> Error occurred: Negative numbers not supported  #> > 2025-06-17 12:39:15 [WORKFLOW] Executing node: condition_1  #> > 2025-06-17 12:39:15 [WORKFLOW] Condition node 'condition_1' selected branches: error  #> > 2025-06-17 12:39:15 [WORKFLOW] Executing branch 'error' -> node 'fallback_1'  #> > 2025-06-17 12:39:15 [WORKFLOW] Executing node: fallback  #> Using fallback processing... #> $error #> [1] \"Fallback result for: Error: Negative numbers not supported\" #>  #>  #> --- Testing input: 42 --- #> > 2025-06-17 12:39:15 [WORKFLOW] Executing node: safe_process  #> > 2025-06-17 12:39:15 [WORKFLOW] Executing node: condition_1  #> > 2025-06-17 12:39:15 [WORKFLOW] Condition node 'condition_1' selected branches: success  #> > 2025-06-17 12:39:15 [WORKFLOW] Executing branch 'success' -> node 'finalize_1'  #> > 2025-06-17 12:39:15 [WORKFLOW] Executing node: finalize  #> $success #> [1] \"Success: Processed: 42\""},{"path":[]},{"path":"https://llmr.opifex.org/articles/advanced-workflows.html","id":"design-clear-condition-functions","dir":"Articles","previous_headings":"Introduction > Best Practices for Advanced Workflows","what":"1. Design Clear Condition Functions","title":"Advanced Workflows: Conditional and Dynamic Patterns","text":"","code":"# Good: Clear, single-purpose condition classify_by_size <- function(data) {   if (length(data) > 1000) \"large\"   else if (length(data) > 100) \"medium\"   else \"small\" }  # Good: Descriptive branch names size_router <- when(   classify_by_size,   large = step(batch_processor, name = \"batch_process\"),   medium = step(standard_processor, name = \"standard_process\"),   small = step(quick_processor, name = \"quick_process\") )"},{"path":"https://llmr.opifex.org/articles/advanced-workflows.html","id":"handle-edge-cases","dir":"Articles","previous_headings":"Introduction > Best Practices for Advanced Workflows","what":"2. Handle Edge Cases","title":"Advanced Workflows: Conditional and Dynamic Patterns","text":"","code":"# Always include fallback branches robust_classifier <- function(data) {   if (is.null(data)) return(\"null\")   if (length(data) == 0) return(\"empty\")   if (is.character(data)) return(\"text\")   if (is.numeric(data)) return(\"number\")   \"unknown\"  # Fallback for unexpected types }"},{"path":"https://llmr.opifex.org/articles/advanced-workflows.html","id":"use-meaningful-names","dir":"Articles","previous_headings":"Introduction > Best Practices for Advanced Workflows","what":"3. Use Meaningful Names","title":"Advanced Workflows: Conditional and Dynamic Patterns","text":"","code":"# Good: Descriptive workflow and step names data_pipeline <- step(validate_input, name = \"validate\") %->%   when(     classify_data_complexity,     simple = step(fast_processor, name = \"fast_track\"),     complex = step(thorough_processor, name = \"deep_analysis\")   ) %->%   step(format_output, name = \"finalize\")"},{"path":"https://llmr.opifex.org/articles/advanced-workflows.html","id":"summary","dir":"Articles","previous_headings":"Introduction","what":"Summary","title":"Advanced Workflows: Conditional and Dynamic Patterns","text":"Advanced workflows llmr provide powerful capabilities building sophisticated data processing systems: () enables conditional branching based data characteristics Parallel processing executes multiple branches simultaneously Dynamic routing adapts workflow behavior input data Multi-stage patterns combine preprocessing, analysis, post-processing Error handling creates robust, fault-tolerant workflows Agent integration adds intelligent decision-making capabilities patterns can combined create highly sophisticated, adaptive processing systems handle complex real-world scenarios intelligence resilience.","code":""},{"path":"https://llmr.opifex.org/articles/advanced-workflows.html","id":"whats-next","dir":"Articles","previous_headings":"Introduction","what":"What’s Next?","title":"Advanced Workflows: Conditional and Dynamic Patterns","text":"advanced patterns, can build: - Intelligent document processing systems - Adaptive data analysis pipelines - Multi-modal content processors - Fault-tolerant production workflows - AI-powered decision trees combination conditional logic, parallel processing, AI agents makes llmr workflows incredibly powerful tackling complex, real-world data processing challenges.","code":""},{"path":"https://llmr.opifex.org/articles/get-started.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Get Started with llmr","text":"llmr package provides flexible R interface large language models (LLMs) support multiple providers, conversation management, tool use. vignette get started basics: creating agent equipping simple calculator tool.","code":""},{"path":"https://llmr.opifex.org/articles/get-started.html","id":"what-youll-learn","dir":"Articles","previous_headings":"Introduction","what":"What You’ll Learn","title":"Get Started with llmr","text":"end guide, ’ll understand : Set LLM provider (Anthropic’s Claude) Create AI agent Add calculator tool agent conversation agent can perform calculations","code":""},{"path":"https://llmr.opifex.org/articles/get-started.html","id":"prerequisites","dir":"Articles","previous_headings":"Introduction","what":"Prerequisites","title":"Get Started with llmr","text":"begin, ’ll need: API key supported LLM provider (’ll use Anthropic’s Claude example) mcpr package installed (creating tools)","code":"library(llmr) #>  #> Attaching package: 'llmr' #> The following object is masked from 'package:stats': #>  #>     step library(mcpr) #>  #> Attaching package: 'mcpr' #> The following object is masked from 'package:methods': #>  #>     initialize #> The following object is masked from 'package:base': #>  #>     write"},{"path":"https://llmr.opifex.org/articles/get-started.html","id":"step-1-set-up-your-provider","dir":"Articles","previous_headings":"Introduction","what":"Step 1: Set Up Your Provider","title":"Get Started with llmr","text":"First, need configure LLM provider. ’ll use Anthropic’s Claude, llmr also supports OpenAI. Important: Replace \"-anthropic-api-key-\" actual Anthropic API key. can get one Anthropic’s website.","code":"# Create a provider instance provider <- new_anthropic()"},{"path":"https://llmr.opifex.org/articles/get-started.html","id":"step-2-create-your-first-agent","dir":"Articles","previous_headings":"Introduction","what":"Step 2: Create Your First Agent","title":"Get Started with llmr","text":"agent AI assistant can use tools help solve problems. Let’s create simple calculator agent: ’s ! now basic agent, can’t much yet. Let’s give capabilities.","code":"# Create an agent with a descriptive name agent <- new_agent(\"calculator\", provider)"},{"path":"https://llmr.opifex.org/articles/get-started.html","id":"step-3-create-a-calculator-tool","dir":"Articles","previous_headings":"Introduction","what":"Step 3: Create a Calculator Tool","title":"Get Started with llmr","text":"Tools allow agent perform specific actions. ’ll create calculator tool can perform basic arithmetic operations: Let’s break tool : Name description: Identifies tool explains purpose operation: Must one “add”, “subtract”, “multiply”, “divide” b: two numbers operate Handler function: actual R code performs calculation","code":"# Create a calculator tool calculator <- new_tool(   name = \"calculator\",   description = \"Performs basic arithmetic operations\",   input_schema = schema(     properties = properties(       operation = property_enum(         \"Operation\",         \"Math operation to perform\",         values = c(\"add\", \"subtract\", \"multiply\", \"divide\"),         required = TRUE       ),       a = property_number(\"First number\", \"First operand\", required = TRUE),       b = property_number(\"Second number\", \"Second operand\", required = TRUE)     )   ),   handler = function(params) {     result <- switch(       params$operation,       \"add\" = params$a + params$b,       \"subtract\" = params$a - params$b,       \"multiply\" = params$a * params$b,       \"divide\" = params$a / params$b     )     response_text(result)   } )"},{"path":"https://llmr.opifex.org/articles/get-started.html","id":"step-4-add-the-tool-to-your-agent","dir":"Articles","previous_headings":"Introduction","what":"Step 4: Add the Tool to Your Agent","title":"Get Started with llmr","text":"Now need give agent access calculator tool: agent now equipped calculation capabilities!","code":"# Add the calculator tool to the agent agent <- add_tool(agent, calculator)"},{"path":"https://llmr.opifex.org/articles/get-started.html","id":"step-5-have-a-conversation","dir":"Articles","previous_headings":"Introduction","what":"Step 5: Have a Conversation","title":"Get Started with llmr","text":"Let’s test calculator agent asking perform calculations:","code":"# Ask the agent to perform a calculation request(agent, \"What is 15 multiplied by 7?\") #> > 2025-06-17 12:39:22 [TOOL] Calling tool: calculator get_last_message(agent) #> assistant: [{\"type\":\"text\",\"text\":\"15 multiplied by 7 equals 105.\"}]"},{"path":"https://llmr.opifex.org/articles/get-started.html","id":"how-it-works","dir":"Articles","previous_headings":"Introduction","what":"How It Works","title":"Get Started with llmr","text":"ask agent question requires calculation: agent analyzes request determines needs perform math calls calculator tool appropriate operation numbers tool performs calculation returns result agent incorporates result natural language response happens automatically - don’t need explicitly tell agent use calculator tool.","code":""},{"path":"https://llmr.opifex.org/articles/get-started.html","id":"step-6-adding-multiple-tools","dir":"Articles","previous_headings":"Introduction","what":"Step 6: Adding Multiple Tools","title":"Get Started with llmr","text":"agent can currently perform calculations, let’s expand capabilities adding simple text formatter tool. demonstrate single request can invoke multiple tools needed. Now agent two tools disposal: calculator text formatter. Let’s ask question requires tools:","code":"# Create a text formatter tool formatter <- new_tool(   name = \"formatter\",   description = \"Format text in different ways\",   input_schema = schema(     properties = properties(       text = property_string(         \"Text\",         \"The text to format\",         required = TRUE       ),       format = property_enum(         \"Format\",         \"The format to apply\",         values = c(\"uppercase\", \"lowercase\", \"reverse\"),         required = TRUE       )     )   ),   handler = function(params) {     result <- switch(       params$format,       \"uppercase\" = toupper(params$text),       \"lowercase\" = tolower(params$text),       \"reverse\" = paste(rev(strsplit(params$text, \"\")[[1]]), collapse = \"\")     )     response_text(result)   } )  # Add the formatter tool to our agent agent <- add_tool(agent, formatter) # Ask a question that requires both calculation and text formatting response <- request(agent, \"Calculate 25 times 4, then convert the result to uppercase Roman numerals.\") #> > 2025-06-17 12:39:31 [TOOL] Calling tool: calculator get_last_message(agent) #> assistant: [{\"type\":\"text\",\"text\":\"25 times 4 equals 100.\\n\\nIn Roman numerals, 100 is written as \\\"C\\\". Since you want it in uppercase, it would be \\\"C\\\" (Roman numerals are traditionally written in uppercase already).\\n\\nNote: The formatter tool I have available can only convert text to uppercase, lowercase, or reverse it - it doesn't convert numbers to Roman numerals. However, I can tell you that 100 in Roman numerals is \\\"C\\\".\"}]"},{"path":"https://llmr.opifex.org/articles/get-started.html","id":"how-multiple-tool-use-works","dir":"Articles","previous_headings":"Introduction","what":"How Multiple Tool Use Works","title":"Get Started with llmr","text":"send request requires multiple tools: agent analyzes request determines tools needs First, uses calculator compute 25 × 4 = 100 , uses formatter convert “C” (Roman numeral 100) uppercase agent combines results coherent response beauty approach don’t need manage tools manually - agent decides tools use order based task hand.","code":""},{"path":"https://llmr.opifex.org/articles/get-started.html","id":"whats-next","dir":"Articles","previous_headings":"Introduction","what":"What’s Next?","title":"Get Started with llmr","text":"Now understand basics, can: Explore providers: Try using OpenAI instead Anthropic Create custom tools: Build tools specific use cases Combine multiple tools: Give agent access several different capabilities Use workflows: Chain multiple agents together complex tasks","code":""},{"path":"https://llmr.opifex.org/articles/get-started.html","id":"key-concepts-summary","dir":"Articles","previous_headings":"Introduction","what":"Key Concepts Summary","title":"Get Started with llmr","text":"Provider: LLM service (Anthropic, OpenAI, etc.) Agent: AI assistant can use tools Tool: function extends agent’s capabilities Schema: Defines structure tool inputs Handler: R function actually performs tool’s work Multiple Tool Use: ability agent use several tools single request llmr package makes easy create powerful AI agents can interact R environment perform real work. Start simple tools like calculator formatter, gradually build sophisticated capabilities become comfortable framework.","code":""},{"path":"https://llmr.opifex.org/articles/mcp-integration.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"MCP Integration: From Development to Production","text":"Model Context Protocol (MCP) standardized way connect AI assistants external tools data sources. llmr package provides seamless integration MCP mcpr package, enabling powerful “lift shift” approach tool development. vignette demonstrates take calculator tool “Get Started” guide deploy production-ready MCP server, maintaining simple client interface.","code":""},{"path":"https://llmr.opifex.org/articles/mcp-integration.html","id":"what-youll-learn","dir":"Articles","previous_headings":"Introduction","what":"What You’ll Learn","title":"MCP Integration: From Development to Production","text":"end guide, ’ll understand : Transform inline tools standalone MCP servers Connect llmr agents external MCP services Leverage “lift shift” approach production deployment Scale tool architecture development production","code":""},{"path":[]},{"path":"https://llmr.opifex.org/articles/mcp-integration.html","id":"development-phase-inline-tools","dir":"Articles","previous_headings":"Introduction > The Development-to-Production Journey","what":"Development Phase: Inline Tools","title":"MCP Integration: From Development to Production","text":"“Get Started” vignette, created calculator tool directly within agent: approach perfect : - Rapid prototyping - Testing new functionality - Simple, single-use tools","code":"# Development approach - tool embedded in agent calculator <- new_tool(   name = \"calculator\",   description = \"Performs basic arithmetic operations\",   input_schema = schema(     properties = properties(       operation = property_enum(         \"Operation\",         \"Math operation to perform\",         values = c(\"add\", \"subtract\", \"multiply\", \"divide\"),         required = TRUE       ),       a = property_number(\"First number\", \"First operand\", required = TRUE),       b = property_number(\"Second number\", \"Second operand\", required = TRUE)     )   ),   handler = function(params) {     result <- switch(       params$operation,       \"add\" = params$a + params$b,       \"subtract\" = params$a - params$b,       \"multiply\" = params$a * params$b,       \"divide\" = params$a / params$b     )     response_text(result)   } ) agent <- add_tool(agent, calculator)"},{"path":"https://llmr.opifex.org/articles/mcp-integration.html","id":"production-phase-mcp-servers","dir":"Articles","previous_headings":"Introduction > The Development-to-Production Journey","what":"Production Phase: MCP Servers","title":"MCP Integration: From Development to Production","text":"production deployment, can “lift shift” tool logic MCP server: approach provides: - Scalability - Tools run separate processes - Reusability - Multiple agents can share tools - Maintainability - Tools can updated independently - Security - Tools run isolated environments","code":"# Production approach - tool as external MCP server client <- new_client_io(command = \"Rscript\", args = \"calculator-server.R\") agent <- register_mcp(agent, client)"},{"path":"https://llmr.opifex.org/articles/mcp-integration.html","id":"step-1-understanding-the-mcp-server","dir":"Articles","previous_headings":"Introduction","what":"Step 1: Understanding the MCP Server","title":"MCP Integration: From Development to Production","text":"Let’s transform calculator tool standalone MCP server. ’s server code looks like: Key Insight: Notice tool definition identical inline version. power “lift shift” approach - code changes required! llmr package includes exact server ready--use example:","code":"library(mcpr)  # Create the same calculator tool from the Get Started guide calculator <- new_tool(   name = \"calculator\",   description = \"Performs basic arithmetic operations\",   input_schema = schema(     properties = properties(       operation = property_enum(         \"Operation\",         \"Math operation to perform\",         values = c(\"add\", \"subtract\", \"multiply\", \"divide\"),         required = TRUE       ),       a = property_number(\"First number\", \"First operand\", required = TRUE),       b = property_number(\"Second number\", \"Second operand\", required = TRUE)     )   ),   handler = function(params) {     result <- switch(       params$operation,       \"add\" = params$a + params$b,       \"subtract\" = params$a - params$b,       \"multiply\" = params$a * params$b,       \"divide\" = params$a / params$b     )     response_text(result)   } )  # Create an MCP server and add the calculator tool mcp_server <- new_server(   name = \"Calculator Server\",   description = \"A production-ready calculator service\",   version = \"1.0.0\" )  # Add the tool to the server mcp_server <- add_capability(mcp_server, calculator)  # Start the server (listening on stdin/stdout) serve_io(mcp_server)"},{"path":"https://llmr.opifex.org/articles/mcp-integration.html","id":"step-2-create-the-mcp-client","dir":"Articles","previous_headings":"Introduction","what":"Step 2: Create the MCP Client","title":"MCP Integration: From Development to Production","text":"Now let’s create agent connects MCP server:","code":"library(llmr) #>  #> Attaching package: 'llmr' #> The following object is masked from 'package:stats': #>  #>     step library(mcpr) #>  #> Attaching package: 'mcpr' #> The following object is masked from 'package:methods': #>  #>     initialize #> The following object is masked from 'package:base': #>  #>     write  # Set up your provider (same as before) provider <- new_anthropic()  # Create an agent agent <- new_agent(\"calculator\", provider)"},{"path":"https://llmr.opifex.org/articles/mcp-integration.html","id":"step-3-connect-to-the-mcp-server","dir":"Articles","previous_headings":"Introduction","what":"Step 3: Connect to the MCP Server","title":"MCP Integration: From Development to Production","text":"Instead adding tools directly, ’ll connect external MCP server. llmr package includes ready--use calculator server: ’s happening : - new_client_io() creates client launches server subprocess - server communicates via stdin/stdout (standard MCP protocol) - register_mcp() makes server tools available agent","code":"# Get the path to the example calculator server included with llmr server_path <- system.file(\"examples\", \"calculator-server.R\", package = \"llmr\")  # Create an MCP client that connects to our calculator server calculator_client <- new_client_io(   command = \"Rscript\",   args = server_path,   name = \"calculator\" )  # Register the MCP client with our agent agent <- register_mcp(agent, calculator_client)"},{"path":"https://llmr.opifex.org/articles/mcp-integration.html","id":"step-4-use-the-agent-same-interface","dir":"Articles","previous_headings":"Introduction","what":"Step 4: Use the Agent (Same Interface!)","title":"MCP Integration: From Development to Production","text":"beauty approach client interface remains exactly :","code":"# Same usage as the inline tool version request(agent, \"What is 25 multiplied by 4?\") #> > 2025-06-17 12:39:42 [TOOL] Calling MCP (calculator) tool: calculator get_last_message(agent) #> assistant: [{\"type\":\"text\",\"text\":\"25 multiplied by 4 equals 100.\"}]  # Complex calculations work the same way request(agent, \"I have 150 dollars, spend 47.50 on dinner and 23.75 on a book. How much is left?\") #> > 2025-06-17 12:39:51 [TOOL] Calling MCP (calculator) tool: calculator  #> > 2025-06-17 12:39:56 [TOOL] Calling MCP (calculator) tool: calculator get_last_message(agent) #> assistant: [{\"type\":\"text\",\"text\":\"You have $78.75 remaining.\"}]"},{"path":[]},{"path":"https://llmr.opifex.org/articles/mcp-integration.html","id":"development-workflow","dir":"Articles","previous_headings":"Introduction > The “Lift and Shift” Advantage","what":"Development Workflow","title":"MCP Integration: From Development to Production","text":"Start inline tools rapid prototyping Test refine tool logic Lift tool definition MCP server Shift agent use MCP client Deploy production client code changes","code":""},{"path":[]},{"path":"https://llmr.opifex.org/articles/mcp-integration.html","id":"scalability","dir":"Articles","previous_headings":"Introduction > The “Lift and Shift” Advantage > Benefits of This Approach","what":"🚀 Scalability","title":"MCP Integration: From Development to Production","text":"","code":"# Multiple agents can share the same calculator service agent1 <- new_agent(\"financial_advisor\", provider) agent2 <- new_agent(\"math_tutor\", provider) agent3 <- new_agent(\"data_analyst\", provider)  # All connect to the same MCP server register_mcp(agent1, calculator_client) register_mcp(agent2, calculator_client) register_mcp(agent3, calculator_client)"},{"path":"https://llmr.opifex.org/articles/mcp-integration.html","id":"reusability","dir":"Articles","previous_headings":"Introduction > The “Lift and Shift” Advantage > Benefits of This Approach","what":"🔄 Reusability","title":"MCP Integration: From Development to Production","text":"One calculator server serves multiple use cases Tools become organizational assets, agent-specific code Easy discover share tools across teams","code":""},{"path":"https://llmr.opifex.org/articles/mcp-integration.html","id":"security-isolation","dir":"Articles","previous_headings":"Introduction > The “Lift and Shift” Advantage > Benefits of This Approach","what":"🛡️ Security & Isolation","title":"MCP Integration: From Development to Production","text":"Tools run separate processes controlled permissions Server crashes don’t affect main agent Easy implement resource limits monitoring","code":""},{"path":"https://llmr.opifex.org/articles/mcp-integration.html","id":"maintainability","dir":"Articles","previous_headings":"Introduction > The “Lift and Shift” Advantage > Benefits of This Approach","what":"🔧 Maintainability","title":"MCP Integration: From Development to Production","text":"Update tool logic without touching agent code Version control tools independently Deploy tool updates without agent restarts","code":""},{"path":[]},{"path":"https://llmr.opifex.org/articles/mcp-integration.html","id":"multiple-mcp-services","dir":"Articles","previous_headings":"Introduction > Advanced MCP Patterns","what":"Multiple MCP Services","title":"MCP Integration: From Development to Production","text":"can connect multiple MCP servers different capabilities:","code":"# Connect to different specialized services calculator_client <- new_client_io(command = \"Rscript\", args = \"calculator-server.R\") weather_client <- new_client_io(command = \"Rscript\", args = \"weather-server.R\") database_client <- new_client_io(command = \"Rscript\", args = \"database-server.R\")  # Register all services with the agent agent <- register_mcp(agent, calculator_client) agent <- register_mcp(agent, weather_client)   agent <- register_mcp(agent, database_client)"},{"path":"https://llmr.opifex.org/articles/mcp-integration.html","id":"hybrid-approach","dir":"Articles","previous_headings":"Introduction > Advanced MCP Patterns","what":"Hybrid Approach","title":"MCP Integration: From Development to Production","text":"can mix inline tools MCP services:","code":"# Quick inline tool for simple tasks simple_tool <- new_tool(name = \"timestamp\", ...) agent <- add_tool(agent, simple_tool)  # External MCP service for complex operations complex_client <- new_client_io(...) agent <- register_mcp(agent, complex_client)"},{"path":[]},{"path":"https://llmr.opifex.org/articles/mcp-integration.html","id":"server-management","dir":"Articles","previous_headings":"Introduction > Production Deployment Considerations","what":"Server Management","title":"MCP Integration: From Development to Production","text":"Use process managers (systemd, Docker, etc.) MCP servers Implement health checks automatic restarts Monitor server performance resource usage","code":""},{"path":"https://llmr.opifex.org/articles/mcp-integration.html","id":"security","dir":"Articles","previous_headings":"Introduction > Production Deployment Considerations","what":"Security","title":"MCP Integration: From Development to Production","text":"Run MCP servers minimal required permissions Use network isolation appropriate Implement authentication sensitive tools","code":""},{"path":"https://llmr.opifex.org/articles/mcp-integration.html","id":"scaling","dir":"Articles","previous_headings":"Introduction > Production Deployment Considerations","what":"Scaling","title":"MCP Integration: From Development to Production","text":"Deploy MCP servers separate machines heavy workloads Use load balancers high-availability tool services Implement caching frequently-used operations","code":""},{"path":[]},{"path":"https://llmr.opifex.org/articles/mcp-integration.html","id":"phase-1-development","dir":"Articles","previous_headings":"Introduction > Migration Strategy","what":"Phase 1: Development","title":"MCP Integration: From Development to Production","text":"","code":"# Start with inline tools agent <- add_tool(agent, my_tool)"},{"path":"https://llmr.opifex.org/articles/mcp-integration.html","id":"phase-2-testing","dir":"Articles","previous_headings":"Introduction > Migration Strategy","what":"Phase 2: Testing","title":"MCP Integration: From Development to Production","text":"","code":"# Test MCP version alongside inline version agent <- add_tool(agent, my_tool)  # Keep original agent <- register_mcp(agent, mcp_client)  # Add MCP version"},{"path":"https://llmr.opifex.org/articles/mcp-integration.html","id":"phase-3-production","dir":"Articles","previous_headings":"Introduction > Migration Strategy","what":"Phase 3: Production","title":"MCP Integration: From Development to Production","text":"","code":"# Remove inline tool, use only MCP agent <- register_mcp(agent, mcp_client)"},{"path":"https://llmr.opifex.org/articles/mcp-integration.html","id":"summary","dir":"Articles","previous_headings":"Introduction","what":"Summary","title":"MCP Integration: From Development to Production","text":"MCP integration llmr provides seamless path development production: Develop quickly inline tools Lift tool definitions MCP servers without code changes Shift agents use MCP clients minimal changes Scale confidently production-ready architecture approach gives best worlds: speed inline development robustness distributed production systems.","code":""},{"path":"https://llmr.opifex.org/articles/mcp-integration.html","id":"key-takeaways","dir":"Articles","previous_headings":"Introduction > Summary","what":"Key Takeaways","title":"MCP Integration: From Development to Production","text":"tool logic works inline MCP modes Client interface remains unchanged migration MCP provides production benefits without development complexity Gradual migration possible recommended Model Context Protocol integration makes llmr powerful platform building scalable AI agent systems can grow prototype production seamlessly.","code":""},{"path":"https://llmr.opifex.org/articles/workflow-basics.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Workflow Basics: Linear Chains","text":"Workflows llmr allow chain together multiple processing steps create sophisticated data processing pipelines. fundamental workflow pattern linear chain, data flows sequentially series steps. vignette introduces basics workflows showing create simple linear chains using regular R functions AI agents steps.","code":""},{"path":"https://llmr.opifex.org/articles/workflow-basics.html","id":"what-youll-learn","dir":"Articles","previous_headings":"Introduction","what":"What You’ll Learn","title":"Workflow Basics: Linear Chains","text":"end guide, ’ll understand : Create workflow steps R functions Create workflow steps AI agents Chain steps together using %->% operator Execute workflows input data Understand flexibility mixing functions agents","code":""},{"path":"https://llmr.opifex.org/articles/workflow-basics.html","id":"prerequisites","dir":"Articles","previous_headings":"Introduction","what":"Prerequisites","title":"Workflow Basics: Linear Chains","text":"","code":"library(llmr) #>  #> Attaching package: 'llmr' #> The following object is masked from 'package:stats': #>  #>     step"},{"path":[]},{"path":"https://llmr.opifex.org/articles/workflow-basics.html","id":"steps","dir":"Articles","previous_headings":"Introduction > Basic Workflow Concepts","what":"Steps","title":"Workflow Basics: Linear Chains","text":"step fundamental building block workflow. Steps can created : - R functions - deterministic processing - AI agents - intelligent, context-aware processing","code":""},{"path":"https://llmr.opifex.org/articles/workflow-basics.html","id":"chains","dir":"Articles","previous_headings":"Introduction > Basic Workflow Concepts","what":"Chains","title":"Workflow Basics: Linear Chains","text":"chain connects steps together using %->% operator, creating pipeline output one step becomes input next.","code":""},{"path":"https://llmr.opifex.org/articles/workflow-basics.html","id":"execution","dir":"Articles","previous_headings":"Introduction > Basic Workflow Concepts","what":"Execution","title":"Workflow Basics: Linear Chains","text":"Execution runs entire workflow input data, passing results step sequence.","code":""},{"path":"https://llmr.opifex.org/articles/workflow-basics.html","id":"example-1-function-based-linear-workflow","dir":"Articles","previous_headings":"Introduction","what":"Example 1: Function-Based Linear Workflow","title":"Workflow Basics: Linear Chains","text":"Let’s start simple workflow using regular R functions: Key Points: - function takes one input returns one output - step() function wraps function use workflows - %->% operator chains steps left--right - execute() runs entire workflow","code":"# Define simple processing functions add_ten <- function(x) {   cat(\"Adding 10 to\", x, \"\\n\")   x + 10 }  multiply_by_two <- function(x) {   cat(\"Multiplying\", x, \"by 2\\n\")   x * 2 }  subtract_five <- function(x) {   cat(\"Subtracting 5 from\", x, \"\\n\")   x - 5 }  # Create workflow steps and chain them together inline math_workflow <- step(add_ten, name = \"add_ten\") %->%   step(multiply_by_two, name = \"multiply_two\") %->%   step(subtract_five, name = \"subtract_five\")  # View the workflow structure print(math_workflow) #> Workflow: <unnamed>  #> Nodes: 3 | Edges: 2  #>  #> ┌─ ⚙️ add_ten #> │ #> ├─ ⚙️ multiply_two #> │ #> └─ ⚙️ subtract_five  # Execute the workflow input_value <- 5 result <- execute(math_workflow, input_value) #> > 2025-06-17 12:40:02 [WORKFLOW] Executing node: add_ten  #> Adding 10 to 5  #> > 2025-06-17 12:40:02 [WORKFLOW] Executing node: multiply_two  #> Multiplying 15 by 2 #> > 2025-06-17 12:40:02 [WORKFLOW] Executing node: subtract_five  #> Subtracting 5 from 30 print(result)  # Should be 25: ((5 + 10) * 2) - 5 = 25 #> [1] 25"},{"path":"https://llmr.opifex.org/articles/workflow-basics.html","id":"example-2-agent-based-linear-workflow","dir":"Articles","previous_headings":"Introduction","what":"Example 2: Agent-Based Linear Workflow","title":"Workflow Basics: Linear Chains","text":"Now let’s create workflow using AI agents text processing: Key Points: - Agents work just like functions workflows - agent processes output previous step - System prompts define agent’s specific role - workflow creates sophisticated text processing pipeline","code":"# Create provider and agents provider <- new_anthropic()  # Create specialized agents summarizer <- new_agent(\"summarizer\", provider) analyzer <- new_agent(\"analyzer\", provider) formatter <- new_agent(\"formatter\", provider)  # Configure each agent with specific instructions set_system_prompt(   summarizer,   \"You are a text summarizer. Provide concise, one-sentence summaries.\" ) set_system_prompt(   analyzer,   \"You are a sentiment analyzer. Analyze the emotional tone and return just the sentiment (positive/negative/neutral).\" ) set_system_prompt(   formatter,   \"You are a formatter. Take the previous analysis and format it as: 'Summary: [summary] | Sentiment: [sentiment]'\" )  # Create workflow by chaining agent steps inline text_workflow <- step(summarizer, name = \"summarize\") %->%   step(analyzer, name = \"analyze_sentiment\") %->%   step(formatter, name = \"format_output\")  # View the workflow structure print(text_workflow)  # Execute the workflow input_text <- \"The new product launch was incredibly successful, exceeding all our expectations.   Customers are thrilled with the innovative features and the team is celebrating this major milestone.\"  result <- execute(text_workflow, input_text) print(result)"},{"path":"https://llmr.opifex.org/articles/workflow-basics.html","id":"example-3-mixed-function-and-agent-workflow","dir":"Articles","previous_headings":"Introduction","what":"Example 3: Mixed Function and Agent Workflow","title":"Workflow Basics: Linear Chains","text":"real power comes mixing functions agents workflow: Key Points: - Functions agents can mixed freely workflows - Functions handle deterministic processing (cleaning, formatting) - Agents handle intelligent analysis interpretation - creates powerful hybrid processing pipelines","code":"# Function to preprocess text clean_text <- function(text) {   # Remove extra whitespace and convert to lowercase   cleaned <- trimws(tolower(text))   cat(\"Cleaned text:\", substr(cleaned, 1, 50), \"...\\n\")   cleaned }  # Function to add metadata add_metadata <- function(analysis) {   # Add timestamp and word count to the analysis   timestamp <- Sys.time()   word_count <- length(strsplit(analysis, \"\\\\s+\")[[1]])      result <- paste0(     \"Analysis: \", analysis, \"\\n\",     \"Generated: \", timestamp, \"\\n\",     \"Word count: \", word_count   )      cat(\"Added metadata\\n\")   result }  # Create an agent for the core analysis analyzer <- new_agent(\"text_analyzer\", provider) set_system_prompt(   analyzer,   \"Analyze the given text and provide insights about its main themes, tone, and key messages. Be concise but thorough.\" )  # Create mixed workflow: function -> agent -> function mixed_workflow <- step(clean_text, name = \"preprocess\") %->%   step(analyzer, name = \"analyze\") %->%   step(add_metadata, name = \"finalize\")  # View the workflow structure print(mixed_workflow)  # Execute the mixed workflow input_text <- \"   THE QUARTERLY RESULTS show STRONG GROWTH across all sectors!   \" result <- execute(mixed_workflow, input_text) print(result)"},{"path":[]},{"path":"https://llmr.opifex.org/articles/workflow-basics.html","id":"data-flow","dir":"Articles","previous_headings":"Introduction > Understanding Workflow Execution","what":"Data Flow","title":"Workflow Basics: Linear Chains","text":"","code":"# Input -> Step 1 -> Step 2 -> Step 3 -> Output #   5   ->   15   ->   30   ->   25   -> Final Result"},{"path":"https://llmr.opifex.org/articles/workflow-basics.html","id":"step-naming","dir":"Articles","previous_headings":"Introduction > Understanding Workflow Execution","what":"Step Naming","title":"Workflow Basics: Linear Chains","text":"","code":"# Steps can be named for clarity my_workflow <- step(my_function, name = \"descriptive_name\") %->%   step(another_function, name = \"another_step\")  # Names appear in workflow output and debugging print(my_workflow)  # Shows step names and visual diagram"},{"path":"https://llmr.opifex.org/articles/workflow-basics.html","id":"error-handling","dir":"Articles","previous_headings":"Introduction > Understanding Workflow Execution","what":"Error Handling","title":"Workflow Basics: Linear Chains","text":"step fails, entire workflow stops:","code":"# Function that might fail risky_function <- function(x) {   if (x < 0) stop(\"Cannot process negative numbers\")   x * 2 }  # Workflow will stop if risky_function fails risky_workflow <- step(risky_function, name = \"risky_step\")"},{"path":[]},{"path":"https://llmr.opifex.org/articles/workflow-basics.html","id":"keep-steps-simple","dir":"Articles","previous_headings":"Introduction > Best Practices","what":"1. Keep Steps Simple","title":"Workflow Basics: Linear Chains","text":"step single, clear responsibility:","code":"# Good: Single responsibility validate_input <- function(x) {   if (!is.numeric(x)) stop(\"Input must be numeric\")   x }  # Good: Single transformation double_value <- function(x) x * 2  # Better than one complex function doing both"},{"path":"https://llmr.opifex.org/articles/workflow-basics.html","id":"use-descriptive-names","dir":"Articles","previous_headings":"Introduction > Best Practices","what":"2. Use Descriptive Names","title":"Workflow Basics: Linear Chains","text":"","code":"# Good: Clear what each step does workflow <- step(validate_input, name = \"validate\") %->%   step(double_value, name = \"double\") %->%   step(format_output, name = \"format\")"},{"path":"https://llmr.opifex.org/articles/workflow-basics.html","id":"design-for-reusability","dir":"Articles","previous_headings":"Introduction > Best Practices","what":"3. Design for Reusability","title":"Workflow Basics: Linear Chains","text":"","code":"# Create reusable steps validation_step <- step(validate_input, name = \"validate\") doubling_step <- step(double_value, name = \"double\")  # Use in multiple workflows workflow_a <- validation_step %->% doubling_step workflow_b <- validation_step %->% other_step %->% doubling_step"},{"path":[]},{"path":"https://llmr.opifex.org/articles/workflow-basics.html","id":"preprocessing-pipeline","dir":"Articles","previous_headings":"Introduction > Common Patterns","what":"Preprocessing Pipeline","title":"Workflow Basics: Linear Chains","text":"","code":"preprocessing <- step(validate_data, name = \"validate\") %->%   step(clean_data, name = \"clean\") %->%   step(normalize_data, name = \"normalize\")"},{"path":"https://llmr.opifex.org/articles/workflow-basics.html","id":"analysis-pipeline","dir":"Articles","previous_headings":"Introduction > Common Patterns","what":"Analysis Pipeline","title":"Workflow Basics: Linear Chains","text":"","code":"analysis <- step(analyzer_agent, name = \"analyze\") %->%   step(extract_insights, name = \"extract\") %->%   step(format_results, name = \"format\")"},{"path":"https://llmr.opifex.org/articles/workflow-basics.html","id":"full-processing-pipeline","dir":"Articles","previous_headings":"Introduction > Common Patterns","what":"Full Processing Pipeline","title":"Workflow Basics: Linear Chains","text":"","code":"complete_pipeline <- preprocessing %->% analysis"},{"path":"https://llmr.opifex.org/articles/workflow-basics.html","id":"whats-next","dir":"Articles","previous_headings":"Introduction","what":"What’s Next?","title":"Workflow Basics: Linear Chains","text":"Now understand linear workflows, can explore: Conditional workflows - Branching based data conditions Parallel workflows - Processing multiple paths simultaneously Complex workflows - Combining linear, conditional, parallel patterns Workflow composition - Building larger workflows smaller ones","code":""},{"path":"https://llmr.opifex.org/articles/workflow-basics.html","id":"summary","dir":"Articles","previous_headings":"Introduction","what":"Summary","title":"Workflow Basics: Linear Chains","text":"Linear workflows provide powerful way chain together processing steps: Steps can created functions agents Chains use %->% operator connect steps Mixed workflows combine deterministic power functions intelligence agents Simple patterns can composed sophisticated processing pipelines flexibility mix functions agents makes llmr workflows incredibly versatile building everything simple data processing pipelines complex AI-powered analysis systems.","code":""},{"path":"https://llmr.opifex.org/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"John Coene. Author, maintainer. Opifex. Copyright holder, funder.","code":""},{"path":"https://llmr.opifex.org/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Coene J (2025). llmr: Interface Large Language Models. R package version 0.0.0.9000.","code":"@Manual{,   title = {llmr: Interface to Large Language Models},   author = {John Coene},   year = {2025},   note = {R package version 0.0.0.9000}, }"},{"path":"https://llmr.opifex.org/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Interface to Large Language Models","text":"llmr provides streamlined interface LLM providers like Anthropic’s Claude OpenAI. package allows : Create manage conversation history LLMs Define agents custom tools LLMs can use Handle structured responses tool calls Integrate external tools via mcpr package","code":""},{"path":"https://llmr.opifex.org/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Interface to Large Language Models","text":"","code":"pak::pak(\"devOpifex/llmr\")"},{"path":"https://llmr.opifex.org/index.html","id":"basic-usage","dir":"","previous_headings":"","what":"Basic Usage","title":"Interface to Large Language Models","text":"","code":"library(llmr)  # Set your Anthropic API key set_api_key(\"your-api-key\")  # Or use ANTHROPIC_API_KEY environment variable  # Create a provider provider <- new_anthropic()  # defaults to user role message <- new_message(\"Explain quantum computing in simple terms\")  # Send request and get response request(provider, message)  # Print the last message get_last_message(provider)  # Continue the conversation message <- new_message(\"Now give me a simple code example\") request(provider, message)  # get all clear_messages get_messages(provider)  # Clear conversation history clear_messages(provider)"},{"path":"https://llmr.opifex.org/index.html","id":"creating-a-simple-agent","dir":"","previous_headings":"","what":"Creating a Simple Agent","title":"Interface to Large Language Models","text":"Note leverage tooling mcpr package create tools. allows seamless integration MCP (Model Context Protocol) servers.","code":"library(llmr)  # Set your API key set_api_key(\"your_anthropic_api_key\")  # Create a provider (default is Anthropic) provider <- new_anthropic()  # Create a simple agent agent <- new_agent(\"calculator\")  # Add a calculator tool to the agent add_tool(   agent,   mcpr::new_tool(     name = \"weather\",     description = \"Get the weather forecast for a given location\",     input_schema = mcpr::schema(       properties = mcpr::properties(         location = mcpr::property_string(           title = \"Location\",           description = \"The location for which you want the weather forecast\",           required = TRUE         )       )     ),     handler = function(params) {       sprintf(\"The weather forecast for %s is dark and rainy\", params$location)     }   ) )  # Register the agent with the provider provider <- register_agent(provider, agent)  # Make a request to the LLM request(   provider,   new_message(\"What is 123 * 456? Please use the calculate tool.\") )  # Print the response get_last_message(provider)"},{"path":"https://llmr.opifex.org/index.html","id":"integrating-with-mcp-model-context-protocol","dir":"","previous_headings":"","what":"Integrating with MCP (Model Context Protocol)","title":"Interface to Large Language Models","text":"See mcpr create use MCP servers (clients).","code":"library(llmr) library(mcpr)  # Set your API key set_api_key(\"your_anthropic_api_key\")  # Create a provider provider <- new_anthropic()  # Create an MCP client that connects to an external calculator service client <- mcpr::new_client(   command = \"Rscript\",   args = \"/path/to/server.R\",   name = \"calculator\" )  # Register the MCP with the provider register_mcp(provider, client)  # Make a request request(   provider,    new_message(\"Subtract 5 from 10.\") )  # Print the response get_last_message(provider)"},{"path":"https://llmr.opifex.org/index.html","id":"workflows","dir":"","previous_headings":"","what":"Workflows","title":"Interface to Large Language Models","text":"Chain together processing steps agents workflows:","code":"library(llmr)  # Define processing functions add_ten <- function(x) x + 10 multiply_two <- function(x) x * 2  # Create workflow steps step1 <- step(add_ten) step2 <- step(multiply_two)  # Chain steps together workflow <- step1 %->% step2  # Execute workflow result <- execute(workflow, 5)  # Returns 30: (5 + 10) * 2"},{"path":"https://llmr.opifex.org/index.html","id":"configuration","dir":"","previous_headings":"","what":"Configuration","title":"Interface to Large Language Models","text":"","code":"# Set a different model set_model(provider, \"claude-3-haiku-20240307\")  # Set max tokens for response set_max_tokens(provider, 1024)  # Set API version set_version(provider, \"2023-06-01\")  # Set temperature for response randomness (0.0 to 1.0) set_temperature(provider, 0.7)  # Set system prompt set_system_prompt(provider, \"You are a helpful assistant that specializes in R programming.\")"},{"path":"https://llmr.opifex.org/reference/add_tool.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a tool to an agent — add_tool","title":"Add a tool to an agent — add_tool","text":"Add tool agent","code":""},{"path":"https://llmr.opifex.org/reference/add_tool.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a tool to an agent — add_tool","text":"","code":"add_tool(x, tool, ...)"},{"path":"https://llmr.opifex.org/reference/add_tool.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a tool to an agent — add_tool","text":"x object tool tool created mcpr::new_tool ... Additional arguments passed methods","code":""},{"path":"https://llmr.opifex.org/reference/add_tool.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add a tool to an agent — add_tool","text":"modified object","code":""},{"path":"https://llmr.opifex.org/reference/append_message.html","id":null,"dir":"Reference","previous_headings":"","what":"Add a message to the list — append_message","title":"Add a message to the list — append_message","text":"Add message list","code":""},{"path":"https://llmr.opifex.org/reference/append_message.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add a message to the list — append_message","text":"","code":"append_message(x, message)"},{"path":"https://llmr.opifex.org/reference/append_message.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add a message to the list — append_message","text":"x object class agent. message message object.","code":""},{"path":"https://llmr.opifex.org/reference/clear_messages.html","id":null,"dir":"Reference","previous_headings":"","what":"Clear messages — clear_messages","title":"Clear messages — clear_messages","text":"Clear messages","code":""},{"path":"https://llmr.opifex.org/reference/clear_messages.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clear messages — clear_messages","text":"","code":"clear_messages(provider)"},{"path":"https://llmr.opifex.org/reference/clear_messages.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clear messages — clear_messages","text":"provider object class provider.","code":""},{"path":"https://llmr.opifex.org/reference/clear_messages.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clear messages — clear_messages","text":"response object","code":""},{"path":"https://llmr.opifex.org/reference/execute.html","id":null,"dir":"Reference","previous_headings":"","what":"Execute a workflow — execute","title":"Execute a workflow — execute","text":"Executes workflow given input data, following defined execution flow including conditional branching.","code":""},{"path":"https://llmr.opifex.org/reference/execute.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Execute a workflow — execute","text":"","code":"execute(workflow, input)"},{"path":"https://llmr.opifex.org/reference/execute.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Execute a workflow — execute","text":"workflow workflow object input Initial input data","code":""},{"path":"https://llmr.opifex.org/reference/execute.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Execute a workflow — execute","text":"result workflow execution","code":""},{"path":"https://llmr.opifex.org/reference/find_mcp_by_name.html","id":null,"dir":"Reference","previous_headings":"","what":"Find an MCP by name — find_mcp_by_name","title":"Find an MCP by name — find_mcp_by_name","text":"Find MCP name","code":""},{"path":"https://llmr.opifex.org/reference/find_mcp_by_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find an MCP by name — find_mcp_by_name","text":"","code":"find_mcp_by_name(mcps, name)"},{"path":"https://llmr.opifex.org/reference/find_mcp_by_name.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find an MCP by name — find_mcp_by_name","text":"mcps environment containing MCPs name name MCP find.","code":""},{"path":"https://llmr.opifex.org/reference/find_mcp_by_name.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find an MCP by name — find_mcp_by_name","text":"MCP object NULL found","code":""},{"path":"https://llmr.opifex.org/reference/get_last_message.html","id":null,"dir":"Reference","previous_headings":"","what":"Get last message — get_last_message","title":"Get last message — get_last_message","text":"Get last message","code":""},{"path":"https://llmr.opifex.org/reference/get_last_message.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get last message — get_last_message","text":"","code":"get_last_message(x)"},{"path":"https://llmr.opifex.org/reference/get_last_message.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get last message — get_last_message","text":"x object class agent.","code":""},{"path":"https://llmr.opifex.org/reference/get_last_message.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get last message — get_last_message","text":"list messages","code":""},{"path":"https://llmr.opifex.org/reference/get_messages.html","id":null,"dir":"Reference","previous_headings":"","what":"Get messages — get_messages","title":"Get messages — get_messages","text":"Get messages","code":""},{"path":"https://llmr.opifex.org/reference/get_messages.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get messages — get_messages","text":"","code":"get_messages(x)"},{"path":"https://llmr.opifex.org/reference/get_messages.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get messages — get_messages","text":"x object class agent.","code":""},{"path":"https://llmr.opifex.org/reference/get_messages.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get messages — get_messages","text":"list messages","code":""},{"path":"https://llmr.opifex.org/reference/grapes-greater-than-grapes.html","id":null,"dir":"Reference","previous_headings":"","what":"Workflow pipe operator — %->%","title":"Workflow pipe operator — %->%","text":"Chains workflow steps together create execution flows. Can connect steps steps, steps workflows, workflows steps, start workflows conditional branching.","code":""},{"path":"https://llmr.opifex.org/reference/grapes-greater-than-grapes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Workflow pipe operator — %->%","text":"","code":"lhs %->% rhs"},{"path":"https://llmr.opifex.org/reference/grapes-greater-than-grapes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Workflow pipe operator — %->%","text":"lhs Left-hand side (step, workflow, ) rhs Right-hand side (step, workflow, )","code":""},{"path":"https://llmr.opifex.org/reference/grapes-greater-than-grapes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Workflow pipe operator — %->%","text":"workflow object","code":""},{"path":"https://llmr.opifex.org/reference/message.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a message — message","title":"Create a message — message","text":"Create message","code":""},{"path":"https://llmr.opifex.org/reference/message.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a message — message","text":"","code":"new_message(content, role = \"user\")"},{"path":"https://llmr.opifex.org/reference/message.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a message — message","text":"content Content message role Role message","code":""},{"path":"https://llmr.opifex.org/reference/message.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a message — message","text":"message object","code":""},{"path":"https://llmr.opifex.org/reference/message.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a message — message","text":"","code":"message <- new_message(\"Hello, world!\")"},{"path":"https://llmr.opifex.org/reference/new_agent.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a new agent — new_agent","title":"Create a new agent — new_agent","text":"Creates new agent specified name","code":""},{"path":"https://llmr.opifex.org/reference/new_agent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a new agent — new_agent","text":"","code":"new_agent(name, provider)"},{"path":"https://llmr.opifex.org/reference/new_agent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a new agent — new_agent","text":"name Character string specifying agent name provider object class provider.","code":""},{"path":"https://llmr.opifex.org/reference/new_agent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a new agent — new_agent","text":"object class \"agent\"","code":""},{"path":"https://llmr.opifex.org/reference/new_workflow.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a new workflow — new_workflow","title":"Create a new workflow — new_workflow","text":"Creates new workflow object can contain steps manage execution flow.","code":""},{"path":"https://llmr.opifex.org/reference/new_workflow.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a new workflow — new_workflow","text":"","code":"new_workflow(name = NULL)"},{"path":"https://llmr.opifex.org/reference/new_workflow.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a new workflow — new_workflow","text":"name Optional name workflow","code":""},{"path":"https://llmr.opifex.org/reference/new_workflow.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a new workflow — new_workflow","text":"workflow object","code":""},{"path":"https://llmr.opifex.org/reference/register_mcp.html","id":null,"dir":"Reference","previous_headings":"","what":"Register a memory client provider — register_mcp","title":"Register a memory client provider — register_mcp","text":"Register memory client provider","code":""},{"path":"https://llmr.opifex.org/reference/register_mcp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Register a memory client provider — register_mcp","text":"","code":"register_mcp(x, mcp)"},{"path":"https://llmr.opifex.org/reference/register_mcp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Register a memory client provider — register_mcp","text":"x object class agent. mcp object class client \"mcpr\" package.","code":""},{"path":"https://llmr.opifex.org/reference/register_mcp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Register a memory client provider — register_mcp","text":"provider object","code":""},{"path":"https://llmr.opifex.org/reference/request.html","id":null,"dir":"Reference","previous_headings":"","what":"Make a request to an LLM provider — request","title":"Make a request to an LLM provider — request","text":"Make request LLM provider","code":""},{"path":"https://llmr.opifex.org/reference/request.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make a request to an LLM provider — request","text":"","code":"request(x, message = NULL, ...)"},{"path":"https://llmr.opifex.org/reference/request.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make a request to an LLM provider — request","text":"x object class provider agent. message message object. ... Additional arguments passed methods.","code":""},{"path":"https://llmr.opifex.org/reference/request.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make a request to an LLM provider — request","text":"response object","code":""},{"path":"https://llmr.opifex.org/reference/request.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Make a request to an LLM provider — request","text":"can make request message = NULL agent send history conversation LLM provider.","code":""},{"path":"https://llmr.opifex.org/reference/set_api_key.html","id":null,"dir":"Reference","previous_headings":"","what":"Set the key for an LLM provider — set_api_key","title":"Set the key for an LLM provider — set_api_key","text":"Set key LLM provider","code":""},{"path":"https://llmr.opifex.org/reference/set_api_key.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set the key for an LLM provider — set_api_key","text":"","code":"set_api_key(x, key, ...)"},{"path":"https://llmr.opifex.org/reference/set_api_key.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set the key for an LLM provider — set_api_key","text":"x provider object key Character string specifying API key ... Additional arguments passed methods","code":""},{"path":"https://llmr.opifex.org/reference/set_api_key.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set the key for an LLM provider — set_api_key","text":"modified object","code":""},{"path":"https://llmr.opifex.org/reference/set_max_tokens.html","id":null,"dir":"Reference","previous_headings":"","what":"Set the token for an LLM provider — set_max_tokens","title":"Set the token for an LLM provider — set_max_tokens","text":"Set token LLM provider","code":""},{"path":"https://llmr.opifex.org/reference/set_max_tokens.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set the token for an LLM provider — set_max_tokens","text":"","code":"set_max_tokens(x, max, ...)"},{"path":"https://llmr.opifex.org/reference/set_max_tokens.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set the token for an LLM provider — set_max_tokens","text":"x provider object max Integer specifying maximum number tokens generate ... Additional arguments passed methods","code":""},{"path":"https://llmr.opifex.org/reference/set_max_tokens.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set the token for an LLM provider — set_max_tokens","text":"modified object","code":""},{"path":"https://llmr.opifex.org/reference/set_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Set the model for an LLM provider — set_model","title":"Set the model for an LLM provider — set_model","text":"Set model LLM provider","code":""},{"path":"https://llmr.opifex.org/reference/set_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set the model for an LLM provider — set_model","text":"","code":"set_model(x, name, ...)"},{"path":"https://llmr.opifex.org/reference/set_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set the model for an LLM provider — set_model","text":"x object name Character string specifying model name ... Additional arguments passed methods","code":""},{"path":"https://llmr.opifex.org/reference/set_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set the model for an LLM provider — set_model","text":"modified object","code":""},{"path":"https://llmr.opifex.org/reference/set_retry.html","id":null,"dir":"Reference","previous_headings":"","what":"Set Retry Parameters for LLM Provider — set_retry","title":"Set Retry Parameters for LLM Provider — set_retry","text":"Configure retry behavior API requests made provider.","code":""},{"path":"https://llmr.opifex.org/reference/set_retry.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set Retry Parameters for LLM Provider — set_retry","text":"","code":"set_retry(x, max_tries = 3, ...)"},{"path":"https://llmr.opifex.org/reference/set_retry.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set Retry Parameters for LLM Provider — set_retry","text":"x object class provider agent. max_tries Maximum number retry attempts (default: 3). ... Additional retry parameters.","code":""},{"path":"https://llmr.opifex.org/reference/set_retry.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set Retry Parameters for LLM Provider — set_retry","text":"provider object updated retry settings.","code":""},{"path":"https://llmr.opifex.org/reference/set_retry.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set Retry Parameters for LLM Provider — set_retry","text":"","code":"if (FALSE) { # \\dontrun{ provider <- new_anthropic() |>   set_retry(max_tries = 5) } # }"},{"path":"https://llmr.opifex.org/reference/set_system_prompt.html","id":null,"dir":"Reference","previous_headings":"","what":"Set the system prompt for an LLM provider — set_system_prompt","title":"Set the system prompt for an LLM provider — set_system_prompt","text":"Set system prompt LLM provider","code":""},{"path":"https://llmr.opifex.org/reference/set_system_prompt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set the system prompt for an LLM provider — set_system_prompt","text":"","code":"set_system_prompt(x, prompt, ...)"},{"path":"https://llmr.opifex.org/reference/set_system_prompt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set the system prompt for an LLM provider — set_system_prompt","text":"x object prompt Character string containing system prompt ... Additional arguments passed methods","code":""},{"path":"https://llmr.opifex.org/reference/set_system_prompt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set the system prompt for an LLM provider — set_system_prompt","text":"modified object","code":""},{"path":"https://llmr.opifex.org/reference/set_temperature.html","id":null,"dir":"Reference","previous_headings":"","what":"Set the temperature for an LLM provider — set_temperature","title":"Set the temperature for an LLM provider — set_temperature","text":"Set temperature LLM provider","code":""},{"path":"https://llmr.opifex.org/reference/set_temperature.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set the temperature for an LLM provider — set_temperature","text":"","code":"set_temperature(x, temperature, ...)"},{"path":"https://llmr.opifex.org/reference/set_temperature.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set the temperature for an LLM provider — set_temperature","text":"x object class provider agent temperature Numeric value specifying temperature (typically 0 1) ... Additional arguments passed methods","code":""},{"path":"https://llmr.opifex.org/reference/set_temperature.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set the temperature for an LLM provider — set_temperature","text":"modified object","code":""},{"path":"https://llmr.opifex.org/reference/set_version.html","id":null,"dir":"Reference","previous_headings":"","what":"Set the version for an LLM provider — set_version","title":"Set the version for an LLM provider — set_version","text":"Set version LLM provider","code":""},{"path":"https://llmr.opifex.org/reference/set_version.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set the version for an LLM provider — set_version","text":"","code":"set_version(x, version, ...)"},{"path":"https://llmr.opifex.org/reference/set_version.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set the version for an LLM provider — set_version","text":"x provider object version Character string specifying API version ... Additional arguments passed methods","code":""},{"path":"https://llmr.opifex.org/reference/set_version.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set the version for an LLM provider — set_version","text":"modified object","code":""},{"path":"https://llmr.opifex.org/reference/step.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a workflow step — step","title":"Create a workflow step — step","text":"Creates step can used workflows. Steps can wrap functions agents provide processing capabilities.","code":""},{"path":"https://llmr.opifex.org/reference/step.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a workflow step — step","text":"","code":"step(x, ...)"},{"path":"https://llmr.opifex.org/reference/step.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a workflow step — step","text":"x agent function use step ... Additional arguments","code":""},{"path":"https://llmr.opifex.org/reference/step.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a workflow step — step","text":"workflow step object","code":""},{"path":"https://llmr.opifex.org/reference/when.html","id":null,"dir":"Reference","previous_headings":"","what":"Create conditional branching in workflows — when","title":"Create conditional branching in workflows — when","text":"Creates conditional branch point workflow execution can follow different paths based condition function.","code":""},{"path":"https://llmr.opifex.org/reference/when.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create conditional branching in workflows — when","text":"","code":"when(condition_fn, ...)"},{"path":"https://llmr.opifex.org/reference/when.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create conditional branching in workflows — when","text":"condition_fn function takes current data returns character vector branch names execute ... Named arguments names branch names values workflow steps sub-workflows","code":""},{"path":"https://llmr.opifex.org/reference/when.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create conditional branching in workflows — when","text":"workflow branching object","code":""}]
